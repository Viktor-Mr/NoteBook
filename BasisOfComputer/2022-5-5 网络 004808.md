

# 网络分层结构



计算机网络体系大致分为三种，OSI 七层模型、TCP/IP四层模型 和 五层模型

![](http://mk-images.tagao.top/img/202205042100805.png?imageslim)



- **应用层**：为应用程序提供交互服务。在互联网中的应用层协议很多，如<font color='red'>**域名系统DNS（53）、  FTP（20 数据连接 ，21控制连接），SSH（22） HTTP协议（80）、HTTPS（443）、SMTP协议（25）等**</font>。
- **传输层**：<font color='red'>**负责向两台主机进程之间的通信提供数据传输服务**</font>。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
- **网络层**：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。
- **数据链路层**：在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。
- **物理层**：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。



# TCP报头格式

<img src="http://mk-images.tagao.top/img/202205042200263.png?imageslim" style="zoom:70%;" />





<font color='red'>**源端口和目的端口字段**</font>

- TCP源端口：源计算机上的应用程序的端口号，占 16 位。
- TCP目的端口：目标计算机的应用程序端口号，占 16 位。

<font color='red'>**序列号字段**</font>

​	序列号：占 32 位。0~ （2^32  - 1）既 0 ~ 4284967295

* 在 TCP 连接中是面向字节流的，所传送的字节流的每一个字节都会按顺序编号。

* 在TCP建立连接之处，每方需要使用随机数产生器产生一个初始序号（ISN）。
* 由于连接双方各自随机产生初始序号，因此一个TCP连接的通信双方的序号是不同的。

例如 一个TCP需要发送 4500B文件， 初始化ISN为10010，分为5个报文段发送。前四个报文长度为1000B,第五个报文长度为500B。分配规则如下：

​	第一个报文段的字节序号范围为 ：10010~11009

​	第二个报文段的字节序号范围为 ：11010~12009

​	第三个报文段的字节序号范围为 ：12010~13009

​	第四个报文段的字节序号范围为 ：13010~14009

​	第五个报文段的字节序号范围为 ：14010~14509



<font color='red'>**确认号字段**</font>

​	确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示<font color='red'>**接收方期望收到发送方下一个报文段的第一个字节数据的编号**</font>。其值是接收计算机即将接收到的下一个序列号，也就是接收到的字节的序列号 + 1。





<font color='red'>**报文长度**</font>

TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。



<font color='red'>**保留字段**</font>

保留（Reserved）：占 6 位。为 TCP 将来的发展预留空间，目前必须全部为 0。



<font color='red'>**标志位字段**</font>

- <font color='red'>**URG（Urgent 紧急位）**</font>：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
- <font color='red'>**ACK（确认位）**</font>：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
- <font color='red'>**PSH（Push 推送位）**</font>：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
- <font color='red'>**RST（复位）**</font>：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
- <font color='red'>**SYN（synchronize 同部位）**</font>：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个<font color='red'>**请求建立连接的报文段**</font>；当 SYN=1，ACK=1 时，表示<font color='red'>**对方同意建立连接**</font>。SYN=1 时，<font color='red'>**说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1**</font>。
- <font color='red'>**FIN（终止位）**</font>：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。



<font color='red'>**窗口大小字段**</font>

窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。



<font color='red'>**TCP 校验和字段**</font>

校验位（TCP Checksum）：占 16 位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。



<font color='red'>**紧急指针字段**</font>

紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。



<font color='red'>**可选项字段**</font>

选项（Option）：长度不定，但长度必须是 32bits 的整数倍。





## 序列号与确认号

​	TCP 协议为了实现可靠传输， <font color='red'>**通信双方需要判断自己已经发送的数据包是否都被接收方收到**</font>， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出**序号（sequence number）** 和 **确认（acknowledgement number）** 的使用。

​	为了实现可靠传输，发送方和接收方始终需要同步( **SYN**chronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。

![](http://mk-images.tagao.top/img/202205051047602.png?imageslim)



# TCP建立连接



## 三次握手



假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是`CLOSED` 。

<img src="http://mk-images.tagao.top/img/202205042145706.png?imageslim" style="zoom:80%;" />



1. 第一次握手：客户端向服务端发起建立连接请求，客户端会<font color='red'>**随机生成一个起始序列号x**</font>，客户端向服务端发送的字段中包含标志位 <font color='red'>**SYN=1**</font> ，序列号<font color='red'>**seq=x**</font>。第一次握手前客户端的状态为 <font color='red'>**CLOSE**</font> ，第一次握手后客户端的状态为 <font color='red'>**SYN-SEND(准备发送)**</font> 。此时服务端的状态为 <font color='red'>**LISTEN（收听）**</font> 。

2.  第二次握手：服务端在收到客户端发来的报文后，会<font color='red'>**随机生成一个服务端的起始序列号y**</font>，然后给客户端回复一段报文，其中包括标志位 <font color='red'>**SYN=1**</font> ， <font color='red'>**ACK=1**</font> ，序列号 <font color='red'>**seq=y**</font> ，确认号 <font color='red'>**ack=x+1**</font> 。第二次握手前服务端的状态为 <font color='red'>**LISTEN **</font>，第二次握手后服务端的状态为 <font color='red'>**SYN-RCVD（准备接收）**</font> ，此时客户端的状态为<font color='red'>**SYN-SENT**</font> 。（其中 SYN=1 表示要和客户端建立一个连接， ACK=1 表示确认序号有效）



3. 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位 <font color='red'>**ACK=1**</font> ，序列号 <font color='red'>**seq=x+1 **</font>，确认号 <font color='red'>**ack=y+1**</font> 。第三次握手前客户端的状态为 <font color='red'>**SYN-SENT **</font>，第三次握手后客户端和服务端的状态都为 <font color='red'>**ESTABLISHED (已建立连接)**</font>。**此时连接建立完成。**



## 两次握手可以吗？



<font color='red'>**角度一：**</font> 

第三次握手主要为了**防止已失效的连接请求报文段**突然又传输到了服务端，导致产生问题。

* 比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。

* 连接成功，等待数据传输完毕后，就释放了连接。

* 然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。

* 如果不采用三次握手，只要B发出确认，就建立新的连接了，**此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。**



* 缺点：连接即使是需要三次握手， 在失效的连接请求报文段发送到服务端时， 也会导致服务器端进入 <font color='red'>**SYN_RECEIVED **</font>状态



<font color='red'>**角度二：**</font>

​	

1. TCP是可靠的

   <font color='red'>**由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。**</font> 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个<font color='red'>**起始值告诉对方，并且对方都要确认收到**</font>。

2. 最简单的建立一个可靠发送通道

   A-------->B   A要发送数据给B，如果没有建立链接就直接发送，大概率石沉大海。所以至少要建立链接。 A先发一个建立链接的请求，B收到后告诉A：“我收到了”。所以需要A发送一次 B发送一次来确保A发送给B是通的。 （这样真的可靠吗？也有可能B告诉A“我收到了”后，这个通道不通了，接下来发送数据给B，B收不到，但是这种情况极少，TCP 有其他机制来得知这种情况）

3. AB互相建立链接需要发送多少个包

   A-------->B B-------->A 从2得知，A到B建立链接需要A给B发一次 B给A发一次两个包，那么AB互相建立链接需要4次，**但是**，B告诉A它收到了和B请求跟A建立链接这两个包可以合成一个，所以需要3次即可

4. AB互相建立链接2个包可以吗？

     从2和3知道，两个包，两次握手只能确保单通道是可靠的，TCP是双工的，需要互相确认都可以发包和收包，所以不能两次握手。

5.正式的过程

1. A向B请求建立链接，<font color='red'>**SYN标志位标记，seq填充为x。**</font>
2. B收到A的建立请求，然后发送SYN标志位标记，<font color='red'>**ACK标记，ack=x+1,seq=y **</font>给A
3. A收到B的收到包和建立请求包，然后发送ACK标记表示接收到SYN包<font color='red'>**ack=y+1，seq=x+1**</font>



[**为什么是三次握手**](https://blog.csdn.net/linyanhou/article/details/111239782?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&utm_relevant_index=1)

[为什么需要三次握手](https://blog.csdn.net/lengxiao1993/article/details/82771768)



# TCP释放连接



##  四次挥手



<img src="http://mk-images.tagao.top/img/202205050001330.png?imageslim" style="zoom:80%;" />



1. 客户端进程向其TCP发出连接释放报文段<font color='red'>**（ FIN=1，seq=u ）u等于客户端发送的最后一个字节的序号加1**</font>，并停止再发送数据，主动关闭TCP连接，进入客户端<font color='red'>**FIN-WAIT-1 （释放等待 - 1）**</font>状态，等待B的确认。

2. B收到连接释放报文段后即发出确认报文段<font color='red'>**（ ACK=1，ack=u+1，seq=v ）v等于服务器发送的最后一个字节的序号加1**</font>，服务端进入<font color='red'>**CLOSE-WAIT（关闭等待）**</font>状态，客户端进行<font color='red'>**FIN-WAIT-2(释放等待 - 2)**</font>。 <font color='red'>**此时的TCP处于半关闭状态，A到B的连接释放，B到A的连接还没有释放（B还需要发送数据到A）。**</font>
3.  B发送完数据，就会向A发出 "连接释放请求报文段"<font color='red'>**（ FIN=1，ACK=1，seq=w，ack=u+1 ）w序号取决于半关闭状态时，服务器端是否发送过数据报文**</font>，B进入<font color='red'>**LAST-ACK（最后确认）**</font>状态，等待A的确认。
4. A收到B的连接释放报文段后，对此发出确认报文段<font color='red'>**（ ACK=1，seq=u+1，ack=w+1 ）**</font>，A进入<font color='red'>**TIME- WAIT （时间等待**</font>状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间 2MSL （最大报文段生存时间）后，A才进入 <font color='red'>**CLOSED **</font>状态。B收到A发出的确认报文段后关闭连接进入<font color='red'>**LISTEN(收听)**</font>，，若没收到A发出的确认报文段，B就会重传连接释放报文段。



## 等待2MSL

* **保证A发送的最后一个ACK报文段能够到达B。**这个 <font color='red'>**ACK **</font>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在 <font color='red'>**2MSL **</font>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动<font color='red'>**2MSL**</font>计时器，最后A和B都进入到 <font color='red'>**CLOSED **</font>状态，若A在 <font color='red'>**TIME-WAIT **</font>状态不等待一段时间，而是发送完<font color='red'>**ACK**</font>报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到 CLOSED 状态。

* **防止已失效的连接请求报文段出现在本连接中**。A在发送完最后一个 <font color='red'>**ACK **</font>报文段后，再经过<font color='red'>**2MSL**</font>，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。



## 为什么是四次挥手

​	因为当Server端收到Client端的 <font color='red'>**SYN **</font>连接请求报文后，可以直接发送 SYN+ACK 报文。但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET，所以Server端先回复一个 ACK 报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。



# TCP特点

* TCP是<font color='red'>**面向连接**</font>的运输层协议。

* **点对点**，每一条TCP连接只能有两个端点。

* TCP提供**可靠交付**的服务。

* TCP提供**全双工通信**。

* **面向字节流**。 



# TCP和UDP的区别

```markdown
- 1. TCP是面向连接的，在进行连接时需要进行三次捂手；UDP是无连接的，即发送数据之前不需要建立连接。
-
- 2. TCP提供可靠的服务；UDP不保证可靠交付。
-
- 3. TCP面向字节流，把数据看成一连串无结构的字节流；UDP是面向报文的。
-
- 4. TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。
-
- 5. 每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的通信方式。
-
```





# HTTP协议

## HTTP协议的特点

1. HTTP允许传输**任意类型**的数据。传输的类型由Content-Type加以标记。

2. **无状态**。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。

3. 支持**客户端/服务器模式**。



## HTTP报文格式



### Request请求

HTTP请求由**请求行、请求头部、空行和请求体**四个部分组成。

**请求行**：包括请求方法，访问的资源URL，使用的HTTP版本。 GET 和 POST 是最常见的HTTP方法，除此以外还包括 DELETE、HEAD、OPTIONS、PUT、TRACE 。

**请求头**：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有 cookie、host、 connection、accept-language、accept-encoding、user-agent 。

**请求体**：用户的请求数据如用户名，密码等。

**请求报文示例**：

![](http://mk-images.tagao.top/img/202205051300152.png?imageslim)





### Response响应

HTTP响应也由四个部分组成，分别是：**状态行、响应头、空行和响应体**。

**状态行**：协议版本，状态码及状态描述。

**响应头**：响应头字段主要有 connection、content-type、content-encoding、content-length、 

set-cookie、Last-Modified，、Cache-Control、Expires 。

**响应体**：服务器返回给客户端的内容。



![](http://mk-images.tagao.top/img/202205051304587.png?imageslim)





## HTTP状态码

![](http://mk-images.tagao.top/img/202205051304153.png?imageslim)



## POST和GET

* GET请求参数通过URL传递，POST的参数放在请求体中。

* GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。

* GET请求会被浏览器主动缓存，而POST不会，除非手动设置。

* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。





## HTTP长连接和短连接？

HTTP短连接：浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

**HTTP 1.0**默认使用的是短连接。

HTTP长连接：指的是**复用TCP连接**。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。

**HTTP 1.1起，默认使用长连接**。要使用长连接，客户端和服务器的HTTP首部的Connection都要设置为keep-alive，才能支持长连接。



## HTTP1.1和HTTP2.0

HTTP 2.0相比HTTP 1.1支持的特性：

* **新的二进制格式**：HTTP 1.1 基于<font color='red'>**文本格式传输数据**</font>；HTTP 2.0采用<font color='red'>**二进制格式传输数据**</font>，解析更高效。

* **多路复用**：在一个连接里，允许同时发送多个请求或响应，**并且这些请求或响应能够并行的传输而不被阻塞**，避免 HTTP 1.1 出现的”队头堵塞”问题。

* **头部压缩**，HTTP 1.1的header带有大量信息，而且每次都要重复发送；HTTP 2.0 把header从数据中分离，并封装成头帧和数据帧，**使用特定算法压缩头帧**，有效减少头信息大小。并且HTTP 2.0**在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。**比如请求a发送了所有的头信息字段，请求b则**只需要发送差异数据**，这样可以减少冗余数据，降低开销。

* **服务端推送**：HTTP 2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。



##  HTTPS与HTTP的区别



1. HTTP是超文本传输协议，信息是**明文传输**；HTTPS则是具有**安全性**的 SSL 加密传输协议。

2.  HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。 

3.  HTTPS协议需要到**CA机构申请证书**，一般需要一定的费用。

4. HTTP运行在TCP协议之上；HTTPS运行在 SSL 协议之上，SSL 运行在TCP协议之上。





## 数字证书

服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：**证书内容、证书签名算法和签名**，签名是为了验证身份。

![](http://mk-images.tagao.top/img/202203291754223.png?imageslim)



服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站。



**数字签名的制作过程**： 

1. CA使用证书签名算法对证书内容进行**hash运算**。 

2. 对hash后的值**用CA的私钥加密**，得到数字签名。



**浏览器验证过程**： 

1. 服务器发送证书给浏览器

2. 获取证书，得到证书内容、证书签名算法和数字签名。
3. 用CA机构的公钥**对数字签名解密**（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。

3. 用证书里的签名算法**对证书内容进行hash运算**。 

4. 比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。







##  DNS的解析

1. 浏览器搜索自己的**DNS缓存**

2.  若没有，则搜索**操作系统中的DNS缓存**和**hosts文件**

3. 若没有，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向**根域名服务器、顶级域名服务器、权限域名服务器**发起查询请求，最终返回IP地址给本地域名服务器。 

4. 本地域名服务器将得到的IP地址返回给**操作系统**，同时自己也将**IP地址缓存起来**

5. 操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来

6. 浏览器得到域名对应的IP地址。

# 浏览器中输入URL



1. 首先是通过DNS服务**解析域名**，找到主机 IP。

2. 浏览器利用 IP地址 直接与网站服务器通信，**三次握手**，建 立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 80 端口发起 TCP 的连接。
3. 建立 TCP 连接后，浏览器向主机发起一个HTTP请求。
4. 服务器**响应请求**，返回响应数据。
5. 浏览器**解析响应内容，进行渲染**，呈现给用户。



![](http://mk-images.tagao.top/img/202205042121430.png?imageslim)



# session

HTTP是无状态协议，因此需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。

<font color='red'>**session就是用于在服务器端保存用户状态的协议**</font>。通常用来保存用户的登录状态。

session工作原理如下：

首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识（sessionid）

如果已经包含了一个sessionid，则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用

如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存

这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。



## 网关

​	大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“[关口](https://baike.baidu.com/item/关口)”，这道关口就是网关。网关（[Gateway](https://baike.baidu.com/item/Gateway)） 就是一个网络连接到另一个网络的“关口”。也就是网络关卡。

​	网关(Gateway)又称[网间连接器](https://baike.baidu.com/item/网间连接器/2943752)、协议转换器。默认网关在[网络](https://baike.baidu.com/item/网络)层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和[路由器](https://baike.baidu.com/item/路由器)类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连 。

​	【说明：由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP！】



​	按照不同的分类标准，网关也有很多种。[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议)里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。

​	那么网关到底是什么呢？网关实质上是一个网络通向其他网络的**<font color='red'>IP地址</font>**。

比如有网络A和网络B，

网络A的[IP](https://baike.baidu.com/item/IP)地址范围为“192.168.1.1~192. 168.1.254”，[子网掩码](https://baike.baidu.com/item/子网掩码)为255.255.255.0；

网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。



在没有[路由器](https://baike.baidu.com/item/路由器)的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台[交换机](https://baike.baidu.com/item/交换机)（或[集线器](https://baike.baidu.com/item/集线器)）上，[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议/212915)也会根据[子网掩码](https://baike.baidu.com/item/子网掩码)（255.255.255.0）与主机的IP 地址作 “与” 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现[数据包](https://baike.baidu.com/item/数据包)的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。

所以说，只有设置好网关的IP地址，[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议/212915)才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？<font color='red'>网关的IP地址</font>是具有路由功能的设备的**IP地址**，具有路由功能的设备有**<font color='red'>路由器</font>**、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。

在和 Novell NetWare 网络交互操作的上下文中，网关在 Windows 网络中使用的服务器信息块 (SMB) 协议以及[NetWare](https://baike.baidu.com/item/NetWare)网络使用的 NetWare 核心协议 (NCP) 之间起着桥梁的[作用](https://baike.baidu.com/item/作用/33062)。网关也被称为 IP路由器。



​	 [默认网关](https://baike.baidu.com/item/默认网关)也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。 [默认网关](https://baike.baidu.com/item/默认网关)的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。 [默认网关](https://baike.baidu.com/item/默认网关)。 [默认网关](https://baike.baidu.com/item/默认网关)一般填写192.168.x.1





## 网桥

​	网桥工作在数据链路层，起到的作用是把多个局域网连接起来，组成更大的局域网。

它的功能主要有两点：过滤和转发。

 	通常来看，网桥起到了把不同局域网连接在一起的作用，即使这些局域网使用不同的协议比如802.11和802.3。加入一个网桥连接一个802.3和一个802.11，那么网桥转发的时候首先需要把802.3的帧头拆掉，换成802.11的头，再转发给802.11使之适应无线局域网的帧格式。



![](http://mk-images.tagao.top/img/202205041857406.png?imageslim)







  网桥连接着局域网LAN A和LAN B.那么如果主机1给主机2进行通信，1发送消息给网桥，网桥发现目标地址和原地址属于一个局域网，那么他就会**过滤**掉这个消息请求。如果1给11发送消息，网桥发现原地址和目的地址不属于同一个局域网，那么就进行转发功能，把来自LAN A的消息转发给LAN B. 这就是网桥的基本功能。

 

  那么网桥怎么知道主机11是在LAN B上面的？这就涉及到一个非常重要的概念，过滤数据库。网桥把他知道的地址信息都存在这个过滤数据库里面，每次接收一个目的地址，就和数据库里面的数据进行比对，如果发现和源地址不在一个LAN就进行转发；如果在一个局域网下面就过滤掉这个信息。

 过滤数据库是怎么工作的呢？它的转发规则是，网桥从x端口接收到一个帧：

​    ①搜索数据库确定MAC地址是不是在一个端口port上面；

​    ②如果没有找到这个MAC地址，那么把该帧泛洪flooding到所有端口（x除外）；

​    ③如果找到了MAC地址对应应该发往y端口，那么检查y，如果y不处于阻塞态，那么就 从y端口发送，如果是阻塞态，那么不发送。

​    ④如果MAC地址对应的也是x端口，那么不发送，过滤掉这个信息。

​    这样网桥就能通过数据库来进行转发或者过滤了。但是我们知道，主机是可以移动的，也就是说它不一定一直待在某一个局域网下面。并且，每个局域网下面还可能会有新加入的主机，这些情况下过滤路由器就需要不断更新。数据库更新所用到的算法叫做后向学习算法。后向学习算法，顾名思义，就是网桥利用接收的帧的源地址进行学习。到达网桥某个端口的帧的源地址指明了来自那个入境LAN的方向，网桥就可以根据这个MAC地址来更新数据库。

​    举一个例子：网桥数据库最开始没有任何信息。主机1给网桥发送了一个数据帧（网桥用x端口接收），希望转发到LAN B里面的12主机（用端口y）。最开始网桥并不知道应该往哪里转发，因为数据库为空，所以只能泛洪，从y,z,w等等端口广播这个消息。自然12主机能收到这个消息。但是这个过程之后数据库中多了这么一个消息：主机1的MAC地址和如果想转发给A的数据应该通过x端口发送。这样加入12主机想给1主机发消息，网桥就不会泛洪flooding了，而是单单给x端口发送消息就行了，这就是网桥的后向学习算法。



## 区别

网桥和网关的主要区别：

1、网桥就是个硬件网络协议翻译器，就好像两个外国人都不会说对方的语言，那就找个翻译，网桥就是翻译。 



2、网关（协议转换器）就是互连网络中操作在OSI网络层之上的具有协议转换功能设施，所以称为设施，是因为网关不一定是一台设备，有可能在一台主机中实现网关功能。 

3、网桥也可以说相当一个端口少的二层交换机，再者网桥主要由软件实现，交换机主要由硬件实现。

4、安全网关是各种技术的融合，具有重要且独特的保护作用，其范围从协议级过滤到十分复杂的应用级过滤。

OSI七层打一个简单的比喻就像一个公司的高层到低层，一层一层的传输业务。

![](http://mk-images.tagao.top/img/202205041849155.jpg)



## 网卡

网卡是电脑的一个接收信息、转换信息、暂储信息的一个硬件。它是把接受到信息递交给上层，如（CUP）的一个接口。





## 总结

   网关是邮电局,所有的信息必须通过这里的打包、封箱、寻址，才能发出去与收进来；

​    网卡是设备，也就是邮电局邮筒，你家的信箱；

​    而网桥是邮递员，但他只负责一个镇里面(局域网)不负责广域网。

