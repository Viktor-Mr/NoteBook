1.如果我们需要了解多线程，就必须先了解什么是线程，在了解线程之前 我们还需要先了解什么是进程，因为我们的线程是完全依赖于进程而存在的

2.什么是进程?
	我们刚才通过了任务管理器看到了进程的存在
	而通过观察，发现了只有正在运行的程序或者启动的程序才会有进程的存在
	进程:就是正在运行的程序
	进程是系统进行资源分配的，他有独立的单位和资源调用，每一个程序都会有他进程和系统资源
	
3.进程有什么意义?
	单进程的计算机，只能做一件事，因为呀只有一条线让你执行程序
	举例:一边玩游戏(游戏进程),一边听音乐(音乐进程)
	我们现在可以实现多个软件的同时操作，所以说我们现在的计算机的CPU都是支持多进程的，可以在同一个时间段执行多个任务
	注意，我们的多进程并不是提高CPU的性能和效率而是提高CPU的使用率
	
	问题:
		一边玩游戏，一边听音乐是同时进行的吗？
		不是，如果我们的单CPU的话 是不可能出现同时执行多个任务的 在严格的意义上来讲 1个CPU只能同时处理一件事情
		而我们在玩游戏和听音乐的时候，我们发现差不多是同时运行的？现在的CPU有着非常高效的运算和处理能力，我们在执行多个任务的时候 CPU之间的任务切换速度 我们不可能感觉的到
		还有个原因，就是我们现在是多核心的CPU，那么就可以实现多个核心分别处理相同的事情 也就可以实现同时运行
		
4.什么是线程?
	在同一个进程当中有可以执行多个任务，那么这个进程每一个任务我们就可以看成是一个线程
	线程:是程序的执行单元，执行路径，线程也是程序执行的 也可以说是CPU最小的基本单位
	单线程:程序只有一条执行路径
	多线程:执行有多条执行路径

5.多线程有什么意义?
	多线程的存在，不是为了提高程序执行效率，而是提高应用程序(进程)的使用率
	如果我们一个进程里面有多个线程的话，那么在抢夺CPU的资源的时候就会占用优势
	多个线程在抢夺资源的时候。每个线程都是可以参与抢夺了，如果你的进程只有一个线程 那么你可以利用抢夺的资源就会比较小 所以目前来说我们多线程只是为了提高抢夺CPU执行权的几率 并不能提高所谓的效率。
	我们一定要注意一个问题是，我们在抢夺资源的时候 不能保证谁的资源的多 谁的资源少 谁先抢到的问题，因为CPU在资源分配的时候 会有非常严重的随机性。
	

需求:实现一个多线程的程序
 	如何实现?
 		由于线程是依赖于进程而存在的，所以我们在创建线程之前是不是要先创建一个进程
 		而进程是由系统来分配，但是注意的是 我们的java程序是没有办法直接调用CPU或者系统资源
 		但是，我们可以通过C/C++写好的功能去调用，为了解决这个问题 java提供了一个类来进行C/C++的
 		功能调用。
 	那么就是是哪个类这么诡异?
 		Thread
 	通过API发现，我们创建线程的方式有两种 我们先写方式1
 	方式:继承Thread
 	步骤:
 		a.自定义一个线程类叫做MyThread继承成Thread
 		b.重写Run方法
 		c.创建对象
 		d.启动线程


Thread类的基本获取和设置方法
	public final String getName()//获取线程的名称
	public final void setName(String name)
	其实通过构造方法也可以给线程起名字
	Thread.currentThread().getName():
	
	
常见的线程使用:
	
	线程休眠
		public static void sleep(long millis)

	线程加入
		public final void join()

	线程礼让
		public static void yield()

	后台线程
		public final void setDaemon(boolean on)

	中断线程
		public final void stop()
		public void interrupt()


线程的优先级:
	线程有两种调度模型：
		分时调度模型   所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
		抢占式调度模型   优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 
		Java使用的是抢占式调度模型。
		演示如何设置和获取线程优先级
		
	线程的优先级的设置:
		默认的优先级:5
		优先级范围:1-10
		MyThreadPriority mtp = new  MyThreadPriority();
		获取最大优先级:mtp.MAX_PRIORITY
		获取最小优先级:mtp.MIN_PRIORITY
		设置线程优先级:mtp.setPriority(10)
		获取线程优先级:mtp.getPriority()
	构造方法:
		public final int getPriority()
		public final void setPriority(int newPriority)
		
	优先级的设置并不代表你抢夺CPU的资源会给你绝对优先的特权，只是说你在抢夺CPU的资源的时候 有一定几率会有的优先的抢夺到 而且只有你多次运行的时候才能体现出来
	
	java.lang.IllegalArgumentException:
	 	这个异常的抛出是说明你调用某个线程方法的传递一个非常的数据 或者不正确的参数
		
		
方式2:实现Runnable
	步骤:
		A.自定义MyRunnable线程类，实现Runnable的接口
		B.重写run()方法
		C.创建MyRunnable对象
		D.创建Thread类的对象，并把C的步骤做对象作为参数传递
		
使用Runnable的方式实现电影票的程序设计
	通过加入延迟之后，程序出现了问题
	A.出现了相同票被卖了多次
		CPU的操作必须是原子性的(从头到尾一次执行)
	B.出现了负数
		随机性和延迟
		
	
	以上出现这中问题，我们称之为线程安全问题:
		如何解决线程安全问题?
		在解决之前，我们需要了解几个问题?
		a.你的程序是不是多线程的环境		是
		b.你是不是有数据共享的问题		是
		c.你是不是有多条语句操作共享数据  	是
		
	由此可见，我们出现问题是非常的正确的 因为你满足出现问题的所有可能性
	怎么去解决？
		我们的A和B目前都不能解决，那么就只能解决C
	思想:
		我们是不是可以考虑把多条共享的数据包装成一个整体，当t1线程执行的时候，t2就得等待，t2执行的时候 t3就得等待？？
		老师说的很正确，但是柯伟仁说 我早就想到解决的方案 但是是怎么做？？
	
	java为我们提供一个同步锁机制:
		synchronized(对象){
			
				你需要同步的代码
		
		}
		
		a.对象是什么?
			我们随便弄一个对象就ok了，目前来说无所谓
		b.需要同步代码是哪一些？
			我们需要共享的多条代码
		
