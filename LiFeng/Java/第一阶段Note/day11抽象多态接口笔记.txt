多态:同一个对象(事务),在不同时刻体现出来的不同状态
	举例:
		猫是猫,猫是动物
		水(液体,固体,气态)

	多态的前提:
		A.必须存在继承关系
		B.存在方法的重写(不是必须，但是不写就没意义)
			(1)动物  d = new 猫();
			(2)动物  d = new 狗();
		C.父类类型要指向子类对象的
			父 f = new 子();
			
	多态的注意事项:
	多态成员访问的特点:
		A.成员变量
			编译看左边，运行看左左边
		B.成员方法
			编译看左边，运行看右边
		C.静态方法
			编译看左边，运行看左边
		
		因为要实现方法的重写，所以运行看右边
		
		
写一个猫和狗的案例
 		Animal 动物:
 			睡觉	sleep
 			吃饭	eat
 		Tom 猫  extends Animal
 		Dog 狗  extends Animal


 	多态的好处:
 		A.提高了代码的维护性(由继承来维护)
 		B.提高了代码的扩展性(多态来维护)
	多态的弊端:
 		不能使用子类特有的功能
		
	我就想使用子类特有的方法，我就这么傲娇
		可以，允许你放肆一波

	怎么用呢?
		a.直接创建子类的对象，然后调用方法就可以了(可以，但是不合理 完全脱离我们的多态的需求)
		b.把父类对象的引用强制转换成子类对象的引用（向下转型/向下造型）
	
	对象之间的转型的问题:
		向上转型:
			Fu f = new Zi();
		向下转型:
			Zi zi = (Zi)f;
			
抽象类的概述:
 		动物不应该设为具体类，因为动物吃的东西睡得姿势都不同
 		我们应该把具体的一个功能实例化，而不能把抽象的事务给具体表现出来。所以无法表示具体的事务的前提的下 应该为抽象类
 	
 	抽象类特点:
 		a.抽象类和抽象方法必须用abstract关键字修饰
 		b.抽象类不一定有抽象方法，有抽象方法一定是抽象类
 		c.抽象类不能实例化
 			因为他没有具体的实现
 			抽象类有他的构造方法，但是构造方法不能实例化？既然不能实例 那么他的构造方法有什么用？
 				用于子类访问父类的初始化
 		d.抽象的类的子类
 			a.如果你不想重写抽象类的父类，该子类就必须是一个抽象类
 			b.重写父类所有的抽象方法,这个时候 该子类必须是一个具体的类
 			
 		抽象类的实例化，其实是靠具体的子类来实现的 这个也是抽象多态的前提
 			Animal a = new Dog();
			
抽象类类成员特点:
 		成员变量:
			可以是变量,也可以是常量
 		构造方法:有
 				用于子类访问父类数据的初始化
 		成员方法:
 				可以有非抽象的成员,也可以有抽象的成员方法
 		
 		抽象类的成员方法的特征:
 			a.没有方法体
 			b.抽象方法强制要求的其子类要做的事情
 			c.必须有abstract来修饰
			
一个类如果没有抽象方法，可以不可以定义为抽象类，如果可以 有什么意义?
 	A.可以
 	B.不可以被实例化(不可以被创建对象)

 	abstract不能和那些关键字共存
 		private	冲突
		final	冲突	
		static	无意义
		
接口概述:	
接口用关键字interface表示
		格式：interface 接口名 {}
	类实现接口用implements表示
		格式：class 类名 implements 接口名 {}
	接口不能实例化
		那么，接口如何实例化呢?
	按照多态的方式，由具体的子类实例化。其实这也是多态的一种，接口多态。
		接口的子类
		要么是抽象类
		要么重写接口中的所有抽象方法
		
	由此可见，多态的实现方式可以分为如下3个:
		a.基本多态(具体类的多态)(基本不用)
		b.抽象多态(勉强能用)
		c.接口多态(非常常用)
		
接口成员的特点：
 		成员变量:不可以使用变量，只能使用常量
 			   默认的修饰符;public static final  
 		成员方法:只能使用抽象方法
 			默认的修饰符:public abstract
 		构造方法:接口没有提供任何的构造方法
		
类与类、类与接口、接口与接口的关系
	类与类 extends
	继承关系，只能单继承，但是可以多层继承

	类与接口 implements
	实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口

	接口与接口extends
	继承关系，可以单继承，也可以多继承
 			